<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebGL High-Quality Bloom</title>
<style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; background: black; width: 100vw; height: 100vh; }
</style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<script>
const glCanvas = document.getElementById('glCanvas');
const gl = glCanvas.getContext('webgl');
if (!gl) throw 'WebGL not supported';

// Handle resolution
function resize() {
    glCanvas.width = window.innerWidth * window.devicePixelRatio;
    glCanvas.height = window.innerHeight * window.devicePixelRatio;
}
window.addEventListener('resize', resize);
resize();

// Vector and matrix math (same as before)
function vecSub(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function vecCross(a, b) {
    return [
        a[1]*b[2] - a[2]*b[1],
        a[2]*b[0] - a[0]*b[2],
        a[0]*b[1] - a[1]*b[0]
    ];
}
function vecNormalize(v) {
    const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
    return [v[0]/len, v[1]/len, v[2]/len];
}
function vecDot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
function lookAt(eye, target, up) {
    const z = vecNormalize(vecSub(eye, target));
    const x = vecNormalize(vecCross(up, z));
    const y = vecNormalize(vecCross(z, x));
    return [
        x[0], y[0], z[0], 0,
        x[1], y[1], z[1], 0,
        x[2], y[2], z[2], 0,
        -vecDot(x, eye), -vecDot(y, eye), -vecDot(z, eye), 1
    ];
}
function perspective(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2);
    const range = near - far;
    return [
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (near + far) / range, -1,
        0, 0, (2 * near * far) / range, 0
    ];
}
function translation(tx, ty, tz) {
    return [
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        tx, ty, tz, 1
    ];
}
function rotY(a) {
    const c = Math.cos(a), s = Math.sin(a);
    return [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1];
}
function mul(a, b) {
    const r = [];
    for (let i = 0; i < 4; ++i)
        for (let j = 0; j < 4; ++j)
            r[i * 4 + j] = a[i * 4] * b[j] + a[i * 4 + 1] * b[j + 4] + a[i * 4 + 2] * b[j + 8] + a[i * 4 + 3] * b[j + 12];
    return r;
}

// Shader helpers
function shader(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
    return s;
}
function program(vsSrc, fsSrc) {
    const p = gl.createProgram();
    gl.attachShader(p, shader(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(p, shader(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p));
    return p;
}
function createFBO(w, h) {
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    return { fb, tex };
}

// Shaders
const vsCube = `attribute vec3 aPos; uniform mat4 uProj, uView, uModel; void main(){ gl_Position = uProj * uView * uModel * vec4(aPos, 1); }`;
const fsCube = `precision mediump float; uniform vec3 uColor; void main(){ gl_FragColor = vec4(uColor, 1); }`;
const vsQuad = `attribute vec2 aPos; varying vec2 vUv; void main(){ vUv = aPos * 0.5 + 0.5; gl_Position = vec4(aPos, 0, 1); }`;
const fsExtract = `precision mediump float; uniform sampler2D uTex; varying vec2 vUv; void main(){ vec3 c = texture2D(uTex, vUv).rgb; float brightness = dot(c, vec3(0.2126, 0.7152, 0.0722)); gl_FragColor = brightness > 0.7 ? vec4(c, 1.0) : vec4(0); }`;
const fsBlurH = `precision mediump float; uniform sampler2D uTex; uniform float uTexelSize; varying vec2 vUv; void main(){ vec4 sum = vec4(0); for(int i = -5; i <= 5; ++i) sum += texture2D(uTex, vUv + vec2(float(i) * uTexelSize, 0)) * 0.09; gl_FragColor = sum; }`;
const fsBlurV = `precision mediump float; uniform sampler2D uTex; uniform float uTexelSize; varying vec2 vUv; void main(){ vec4 sum = vec4(0); for(int i = -5; i <= 5; ++i) sum += texture2D(uTex, vUv + vec2(0, float(i) * uTexelSize)) * 0.09; gl_FragColor = sum; }`;
const fsFinal = `precision mediump float; uniform sampler2D uScene, uBloom; varying vec2 vUv; void main(){ vec3 scene = texture2D(uScene, vUv).rgb; vec3 bloom = texture2D(uBloom, vUv).rgb; vec3 color = scene + bloom * 1.0; color = pow(color, vec3(1.0/2.2)); gl_FragColor = vec4(color, 1); }`;

// Programs
const progCube = program(vsCube, fsCube);
const progExtract = program(vsQuad, fsExtract);
const progBlurH = program(vsQuad, fsBlurH);
const progBlurV = program(vsQuad, fsBlurV);
const progFinal = program(vsQuad, fsFinal);

// Buffers
const quadBuf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);

const cubeVerts = new Float32Array([-1,-1,1, 1,-1,1, 1,1,1, -1,1,1, -1,-1,-1, -1,1,-1, 1,1,-1, 1,-1,-1]);
const cubeIdx = new Uint16Array([0,1,2,2,3,0,4,5,6,6,7,4,4,0,3,3,5,4,7,6,2,2,1,7,5,3,2,2,6,5,4,7,1,1,0,4]);
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);
const ibo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIdx, gl.STATIC_DRAW);

// Scene setup
const gridSize = 10, spacing = 2.5, cubes = [];
for (let i = 0; i < gridSize; i++)
    for (let j = 0; j < gridSize; j++)
        cubes.push({ pos: [(i - gridSize/2) * spacing, 0, (j - gridSize/2) * spacing], color: [i/gridSize, j/gridSize, 1.0 - i/gridSize], rotation: Math.random() * Math.PI * 2 });

// Draw Helpers
function drawCubes(fbo) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.useProgram(progCube);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    const locPos = gl.getAttribLocation(progCube, 'aPos');
    gl.vertexAttribPointer(locPos, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(locPos);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

    const aspect = glCanvas.width / glCanvas.height;
    const proj = perspective(Math.PI/3, aspect, 0.1, 100);
    const view = lookAt([0, 15, 20], [0, 0, 0], [0, 1, 0]);

    gl.uniformMatrix4fv(gl.getUniformLocation(progCube, 'uProj'), false, proj);
    gl.uniformMatrix4fv(gl.getUniformLocation(progCube, 'uView'), false, view);

    const locModel = gl.getUniformLocation(progCube, 'uModel');
    const locColor = gl.getUniformLocation(progCube, 'uColor');

    for (const cube of cubes) {
        cube.rotation += 0.01;
        const model = mul(translation(...cube.pos), rotY(cube.rotation));
        gl.uniformMatrix4fv(locModel, false, model);
        gl.uniform3fv(locColor, cube.color);
        gl.drawElements(gl.TRIANGLES, cubeIdx.length, gl.UNSIGNED_SHORT, 0);
    }
}

function drawQuad(prog, tex, texelSize = 0) {
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
    const loc = gl.getAttribLocation(prog, 'aPos');
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(loc);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    if (texelSize)
        gl.uniform1f(gl.getUniformLocation(prog, 'uTexelSize'), texelSize);
    gl.uniform1i(gl.getUniformLocation(prog, 'uTex'), 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// Main Render Loop
const bloomScale = 0.75;
let fScene, fBright, fBlurH, fBlurV;

function setupFBOs() {
    fScene = createFBO(glCanvas.width, glCanvas.height);
    fBright = createFBO(glCanvas.width * bloomScale, glCanvas.height * bloomScale);
    fBlurH = createFBO(glCanvas.width * bloomScale, glCanvas.height * bloomScale);
    fBlurV = createFBO(glCanvas.width * bloomScale, glCanvas.height * bloomScale);
}
setupFBOs();
window.addEventListener('resize', setupFBOs);

gl.enable(gl.DEPTH_TEST);
function render() {
    drawCubes(fScene.fb);

    gl.bindFramebuffer(gl.FRAMEBUFFER, fBright.fb);
    gl.viewport(0, 0, glCanvas.width * bloomScale, glCanvas.height * bloomScale);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(progExtract);
    drawQuad(progExtract, fScene.tex);

    gl.bindFramebuffer(gl.FRAMEBUFFER, fBlurH.fb);
    gl.useProgram(progBlurH);
    drawQuad(progBlurH, fBright.tex, 1.0 / glCanvas.width);

    gl.bindFramebuffer(gl.FRAMEBUFFER, fBlurV.fb);
    gl.useProgram(progBlurV);
    drawQuad(progBlurV, fBlurH.tex, 1.0 / glCanvas.height);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, glCanvas.width, glCanvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(progFinal);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, fScene.tex);
    gl.uniform1i(gl.getUniformLocation(progFinal, 'uScene'), 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, fBlurV.tex);
    gl.uniform1i(gl.getUniformLocation(progFinal, 'uBloom'), 1);
    gl.bindBuffer(gl.ARRAY_BUFFER, quadBuf);
    gl.vertexAttribPointer(gl.getAttribLocation(progFinal, 'aPos'), 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(gl.getAttribLocation(progFinal, 'aPos'));
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
